<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Key Points Extracter and Word Meaning Chatbot</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Poppins', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh;
      margin: 0;
      padding: 20px;
      background: linear-gradient(to right, #74ebd5, #acb6e5);
    }

    h1 {
      margin-bottom: 20px;
    }

    .controls,
    .navigation {
      margin-top: 20px;
    }

    button,
    select,
    input[type="text"] {
      margin: 5px;
      padding: 10px 20px;
      font-size: 16px;
      border-radius: 10px;
      border: none;
      cursor: pointer;
    }

    #loader {
      display: none;
    }

    #text-display,
    #key-points,
    #chat-container {
      margin-top: 20px;
      padding: 20px;
      background: white;
      border-radius: 15px;
      max-width: 800px;
      width: 100%;
      font-size: 18px;
      line-height: 1.6;
      overflow-y: auto;
      position: relative;
    }

    #text-display {
      height: 600px;
      width: 90%;
      max-width: 1000px;
      font-size: 18px;
      line-height: 1.6;
      padding: 20px;
      overflow-y: auto;
      background-color: #ffffff;
      border-radius: 15px;
    }

    #chat-display {
      height: 300px;
      overflow-y: auto;
      border: 1px solid #ccc;
      padding: 10px;
      margin-bottom: 10px;
      border-radius: 10px;
      background: #f0f0f0;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .highlight {
      background-color: yellow;
    }

    .user-message,
    .bot-message {
      max-width: 70%;
      padding: 10px;
      border-radius: 10px;
      font-size: 15px;
    }

    .user-message {
      align-self: flex-end;
      background-color: #dcf8c6;
    }

    .bot-message {
      align-self: flex-start;
      background-color: #ffffff;
      border: 1px solid #ccc;
    }

    #popup {
      position: fixed;
      top: 30px;
      right: 30px;
      background: #4CAF50;
      color: white;
      padding: 15px 25px;
      border-radius: 10px;
      display: none;
      font-weight: bold;
      z-index: 999;
      box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2);
    }

    .feedback-container {
      margin-top: 40px;
      text-align: center;
    }

    #feedback-button {
      background-color: #ff9800;
      color: white;
      padding: 12px 25px;
      font-size: 16px;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }

    #feedback-button:hover {
      background-color: #e68900;
    }
  </style>
</head>

<body>
  <h1>Key Points Extracter & Word Meaning Chatbot</h1>

  <div class="navigation">
    <button onclick="location.href='options20.html'">Home</button>
    <button onclick="goBack()">Back</button>
  </div>

  <input type="file" id="file-input" accept=".pdf, .docx, .txt, .xml">
  <div id="loader">Loading...</div>

  <div class="controls">
    <select id="voiceSelect"></select><br>
    <button onclick="startReading()">Start</button>
    <button onclick="pauseReading()">Pause</button>
    <button onclick="stopReading()">Stop</button>
    <button onclick="extractKeyPoints()">Summarize</button>
    <button onclick="readKeyPoints()">Read Key Points</button>
    <button id="copyButton" onclick="copyText()">Copy Text</button>
  </div>

  <div id="text-display"></div>

  <div id="key-points" style="display: none;"></div>

  <div id="chat-container">
    <div id="chat-display"></div>
    <div style="display: flex;">
      <input type="text" id="user-input" placeholder="Enter a word...">
      <button onclick="sendMessage()">Send</button>
    </div>
  </div>

  <div class="feedback-container">
    <button onclick="location.href='feedback20.html'" id="feedback-button">Give Feedback</button>
  </div>

  <div id="popup">Copied to clipboard!</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.13.216/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.2/mammoth.browser.min.js"></script>

  <script>
    const fileInput = document.getElementById('file-input');
    const textDisplay = document.getElementById('text-display');
    const keyPointsDiv = document.getElementById('key-points');
    const loader = document.getElementById('loader');
    const voiceSelect = document.getElementById('voiceSelect');
    const popup = document.getElementById('popup');
    const chatDisplay = document.getElementById('chat-display');
    const userInput = document.getElementById('user-input');

    let speech;
    let keyPointsSpeech;
    let voices = [];

    function populateVoices() {
      voices = window.speechSynthesis.getVoices();
      voiceSelect.innerHTML = '';
      voices.forEach((voice, i) => {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `${voice.name} (${voice.lang})`;
        voiceSelect.appendChild(option);
      });
    }

    if ('speechSynthesis' in window) {
      window.speechSynthesis.onvoiceschanged = populateVoices;
    }

    fileInput.addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (file) {
        loader.style.display = 'block';
        const text = await extractText(file);
        loader.style.display = 'none';
        textDisplay.textContent = text;
        keyPointsDiv.style.display = 'none';
        showPopup('Text extracted successfully!');
      }
    });

    async function extractText(file) {
      const reader = new FileReader();
      return new Promise((resolve, reject) => {
        reader.onload = async function (event) {
          if (file.name.endsWith('.pdf')) {
            const pdf = await pdfjsLib.getDocument({ data: event.target.result }).promise;
            let text = '';
            for (let i = 1; i <= pdf.numPages; i++) {
              const page = await pdf.getPage(i);
              const content = await page.getTextContent();
              text += content.items.map(item => item.str).join(' ') + ' ';
            }
            resolve(text);
          } else if (file.name.endsWith('.docx')) {
            const result = await mammoth.extractRawText({ arrayBuffer: event.target.result });
            resolve(result.value);
          } else if (file.name.endsWith('.txt') || file.name.endsWith('.xml')) {
            const textDecoder = new TextDecoder("utf-8");
            const textContent = textDecoder.decode(event.target.result);
            resolve(textContent);
          } else {
            alert('Unsupported file type!');
            reject();
          }
        };
        reader.readAsArrayBuffer(file);
      });
    }

    function startReading() {
      if (speechSynthesis.speaking) {
        speechSynthesis.resume();
        return;
      }

      const text = textDisplay.textContent;
      speech = new SpeechSynthesisUtterance(text);

      const selectedVoice = voices[voiceSelect.value];
      if (selectedVoice) {
        speech.voice = selectedVoice;
      }

      speech.onboundary = (event) => {
        const index = event.charIndex;
        highlightChar(index);
      };

      speechSynthesis.speak(speech);
      showPopup('Reading started!');
    }

    function pauseReading() {
      if (speechSynthesis.speaking && !speechSynthesis.paused) {
        speechSynthesis.pause();
      }
    }

    function stopReading() {
      speechSynthesis.cancel();
      removeHighlight();
    }

    function highlightChar(index) {
      const text = textDisplay.textContent;
      textDisplay.innerHTML = text.substring(0, index) + '<span class="highlight">' + text.charAt(index) + '</span>' + text.substring(index + 1);
    }

    function removeHighlight() {
      textDisplay.innerHTML = textDisplay.textContent;
    }

    function goHome() {
      alert("Home button clicked! Implement home navigation here.");
    }

    function goBack() {
      location.reload();
    }

    function copyText() {
      const text = textDisplay.textContent;
      navigator.clipboard.writeText(text).then(() => {
        showPopup('Text copied to clipboard!');
      }).catch(err => {
        alert('Failed to copy text: ', err);
      });
    }

    function showPopup(message) {
      popup.textContent = message;
      popup.style.display = 'block';
      setTimeout(() => {
        popup.style.display = 'none';
      }, 2000);
    }

    function extractKeyPoints() {
      const text = textDisplay.textContent;
      if (!text.trim()) {
        alert("Please upload and extract a file first!");
        return;
      }

      const sentences = text.match(/[^\.!\?]+[\.!\?]+/g) || [];
      const keywords = ["important", "key", "notable", "main", "critical", "essential"];
      const keyPoints = [];

      sentences.forEach(sentence => {
        const lower = sentence.toLowerCase();
        if (keywords.some(word => lower.includes(word)) || sentence.length > 100) {
          keyPoints.push(sentence.trim());
        }
      });

      if (keyPoints.length === 0) {
        keyPoints.push("No key points detected automatically. Text might be too short or simple.");
      }

      keyPointsDiv.innerHTML = "<h2>Key Points</h2><ul>" + keyPoints.map(point => `<li>${point}</li>`).join('') + "</ul>";
      keyPointsDiv.style.display = 'block';
      keyPointsDiv.dataset.keypoints = keyPoints.join(" ");
      showPopup('Key points extracted!');
    }

    function readKeyPoints() {
      if (keyPointsDiv.style.display === 'none') {
        alert("Please summarize first!");
        return;
      }

      const keyPointsText = keyPointsDiv.dataset.keypoints || '';
      if (!keyPointsText.trim()) {
        alert("No key points available to read!");
        return;
      }

      keyPointsSpeech = new SpeechSynthesisUtterance(keyPointsText);

      const selectedVoice = voices[voiceSelect.value];
      if (selectedVoice) {
        keyPointsSpeech.voice = selectedVoice;
      }

      speechSynthesis.speak(keyPointsSpeech);
      showPopup('Reading key points!');
    }

    function sendMessage() {
      const userText = userInput.value.trim();
      if (userText === '') return;

      addMessage('You: ' + userText, 'user-message');
      getMeaning(userText.toLowerCase());
      userInput.value = '';
    }

    function addMessage(message, type) {
      const messageDiv = document.createElement('div');
      messageDiv.textContent = message;
      messageDiv.className = type;
      chatDisplay.appendChild(messageDiv);
      chatDisplay.scrollTop = chatDisplay.scrollHeight;
    }

    function getMeaning(word) {
      const meanings = {
        hello: "A greeting or expression of goodwill.",
        world: "The earth, together with all of its countries and peoples.",
        chatbot: "A computer program designed to simulate conversation with human users.",
        love: "An intense feeling of deep affection.",
        friend: "A person whom one knows and with whom one has a bond of mutual affection.",
        learn: "Gain or acquire knowledge of or skill in (something) by study, experience, or being taught.",
        code: "A system of words, letters, or symbols used for communication or programming."
      };

      setTimeout(() => {
        if (meanings[word]) {
          addMessage('Bot: ' + meanings[word], 'bot-message');
        } else {
          fetchMeaningOnline(word);
        }
      }, 500);
    }

    function fetchMeaningOnline(word) {
      fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`)
        .then(response => {
          if (!response.ok) {
            throw new Error('Word not found');
          }
          return response.json();
        })
        .then(data => {
          const meaning = data[0]?.meanings[0]?.definitions[0]?.definition;
          if (meaning) {
            addMessage(`Bot: ${meaning}`, 'bot-message');
          } else {
            addMessage(`Bot: Sorry, no meaning found for "${word}".`, 'bot-message');
          }
        })
        .catch(error => {
          addMessage(`Bot: Sorry, I couldn't find the meaning of "${word}".`, 'bot-message');
        });
    }

    function giveFeedback() {
      alert("Thank you for using the app! We'd love to hear your feedback.");
    }
  </script>
</body>

</html>
